# Predicting Any Filters using Tensorflow

# Import libraries
import tensorflow as tf
import pandas as pd
import numpy as np
from tensorflow import keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import MinMaxScaler

def select_columns(predictor1, predictor2, predictor3, predictor4, prediction):
  # Select columns to be tested
  pred1 = predictor1
  pred2 = predictor2
  pred3 = predictor3
  pred4 = predictor4
  predicted = prediction
  filter = df_real[[pred1, pred2, pred3, pred4]]
  next = df_real[[predicted]]
  xs = np.array(filter, dtype=float)
  ys = np.array(next, dtype=float)
  return xs, ys;

def define_model():
  model = Sequential()
  model.add(LSTM(32, input_shape = (4, 1))),
  model.add(Dense(32)),
  model.add(Dense(1))


  #tf.keras.backend.clear_session() # Resets all state generated by Keras
  #model = tf.keras.Sequential([keras.layers.Dense(units = 1, input_shape = [4], activation='sigmoid')])
  return model;

def train_model(model):
  model.compile(optimizer='Nadam', loss='log_cosh', metrics='accuracy')
  model.fit(xs, ys, epochs = 500, batch_size=16)
  return

def print_prediction(results, rounded_results, prediction):
  print("Filtro a predecir -> " + prediction)
  print(results)
  print(rounded_results)
  return

# Read the CSV file into a DataFrame
file_path = '/Users/gustavo.vaca/Downloads/Pair_Triplet_Quad.csv'
df = pd.read_csv(file_path)

# Select all data except last row
df_real = df[:(len(df)-1)]

# Set filters to be tested
predictor1 = 'Pair_Filter'
predictor2 = 'Pair_up/down'
predictor3 = 'Pair_Up/down_Median'
predictor4 = 'Pair_Prob_Median'
prediction = 'Next_Pair_Up/Down'
xs, ys = select_columns(predictor1, predictor2, predictor3, predictor4, prediction)

# Train the model and predict next value
model = define_model()
train_model(model)

# Calculate the prediction accuracy
results = model.predict(xs)
results = [0 if val <0.5 else 1 for val in results]
model.reset_states()
accuracy_score(ys, results)

# Make a prediction and print predicted value
next_value = df[[predictor1, predictor2, predictor3, predictor4]].tail(1)
results = model.predict(next_value)
rounded_results = np.rint(results)
model.reset_states()
print_prediction(results, rounded_results, prediction)

# Set filters to be tested
predictor1 = 'Triplet_Filter_norm'
predictor2 = 'Triplet_up/down'
predictor3 = 'Triplet_Up/down_Median'
predictor4 = 'Triplet_Prob_Median'
prediction = 'Next_Triplet_Up/Down'
xs, ys = select_columns(predictor1, predictor2, predictor3, predictor4, prediction)

# Train the model and predict next value
model = define_model()
train_model(model)

# Calculate the prediction accuracy
results = model.predict(xs)
results = [0 if val <0.5 else 1 for val in results]
model.reset_states()
accuracy_score(ys, results)

# Make a prediction and print predicted value
next_value = df[[predictor1, predictor2, predictor3, predictor4]].tail(1)
results = model.predict(next_value)
rounded_results = np.rint(results)
model.reset_states()
print_prediction(results, rounded_results, prediction)

# Set filters to be tested
predictor1 = 'Quad_Filter_norm'
predictor2 = 'Quad_up/down'
predictor3 = 'Quad_Up/down_Median'
predictor4 = 'Quad_Prob_Median'
prediction = 'Next_Quad_Up/Down'
xs, ys = select_columns(predictor1, predictor2, predictor3, predictor4, prediction)

# Train the model and predict next value
model = define_model()
train_model(model)

# Calculate the prediction accuracy
results = model.predict(xs)
results = [0 if val <0.5 else 1 for val in results]
model.reset_states()
accuracy_score(ys, results)

# Make a prediction and print predicted value
next_value = df[[predictor1, predictor2, predictor3, predictor4]].tail(1)
results = model.predict(next_value)
rounded_results = np.rint(results)
model.reset_states()
print_prediction(results, rounded_results, prediction)

# Set filters to be tested
predictor1 = 'Quintet_Filter_norm'
predictor2 = 'Quintet_up/down'
predictor3 = 'Quintet_Up/down_Median'
predictor4 = 'Quintet_Prob_Median'
prediction = 'Next_Quintet_Up/Down'
xs, ys = select_columns(predictor1, predictor2, predictor3, predictor4, prediction)

# Train the model and predict next value
model = define_model()
train_model(model)

# Calculate the prediction accuracy
results = model.predict(xs)
results = [0 if val <0.5 else 1 for val in results]
model.reset_states()
accuracy_score(ys, results)

# Make a prediction and print predicted value
next_value = df[[predictor1, predictor2, predictor3, predictor4]].tail(1)
results = model.predict(next_value)
rounded_results = np.rint(results)
model.reset_states()
print_prediction(results, rounded_results, prediction)